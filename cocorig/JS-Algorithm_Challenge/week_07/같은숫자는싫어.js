// //  내 풀이
function solution(arr)
{
    const stack = [];

    for(let i = 0; i < arr.length; i++){
    // stack 배열에 원소 값을 넣어놓고 시작
    stack.push(arr[i]);
    // stack의 top(제일 위에 있는 값)과 다음 값과 같다면 연속된 숫자라고 판단
    if(stack[stack.length - 1] === arr[i + 1]){
      // 다음 반복에서 같은 숫자를 넣기때문에 stack에서 빼준다.
      stack.pop();
    }
  }
  return stack;
}

// 정확성  테스트
// 테스트 1 〉	통과 (0.11ms, 32.9MB)
// 테스트 2 〉	통과 (0.12ms, 32.8MB)
// 테스트 3 〉	통과 (0.12ms, 33.4MB)
// 테스트 4 〉	통과 (0.13ms, 33.4MB)
// 테스트 5 〉	통과 (0.12ms, 33.4MB)
// 테스트 6 〉	통과 (0.13ms, 33.4MB)
// 테스트 7 〉	통과 (0.12ms, 33.4MB)
// 테스트 8 〉	통과 (0.12ms, 33.4MB)
// 테스트 9 〉	통과 (0.12ms, 33.4MB)
// 테스트 10 〉	통과 (0.12ms, 33.3MB)
// 테스트 11 〉	통과 (0.14ms, 33.4MB)
// 테스트 12 〉	통과 (0.14ms, 33.4MB)
// 테스트 13 〉	통과 (0.12ms, 33.4MB)
// 테스트 14 〉	통과 (0.13ms, 33.4MB)
// 테스트 15 〉	통과 (0.12ms, 33.3MB)
// 테스트 16 〉	통과 (0.12ms, 33.3MB)
// 테스트 17 〉	통과 (0.04ms, 33.4MB)
// 효율성  테스트
// 테스트 1 〉	통과 (40.66ms, 83MB)
// 테스트 2 〉	통과 (34.96ms, 82.8MB)
// 테스트 3 〉	통과 (38.19ms, 83MB)
// 테스트 4 〉	통과 (41.70ms, 82.8MB)


//  다른 분 풀이(현재 원소의 값과 다음 인덱스의 값이 일치하는 경우를 걸러내는 방법)
// filter는 true인 값만 반환.
function solution(arr){
  return arr.filter((v,i) => v !== arr[i+1]);
}

// 1 !== 1 -> flase , 현재 값 1을 뺌
// 1 !== 3 -> true , 현재 값 1 남김
// 3 !== 3 -> false , 현재 값 3 뺌
// 3 !== 0 -> true , 현재 값 3 남김
// 0 !== 1 -> true , 현재 값 0 남김
// 1 !== 1 -> flase , 현재 값 1을 뺌
// 1 !== undefined  -> true , 현재 값 1을 남김 
console.log(solution([1,1,3,3,0,1,1]));  // ---> [1,3,0,1]
// 정확성  테스트
// 테스트 1 〉	통과 (0.04ms, 33.3MB)
// 테스트 2 〉	통과 (0.05ms, 33.3MB)
// 테스트 3 〉	통과 (0.05ms, 33.3MB)
// 테스트 4 〉	통과 (0.04ms, 33.3MB)
// 테스트 5 〉	통과 (0.04ms, 33.3MB)
// 테스트 6 〉	통과 (0.04ms, 33.3MB)
// 테스트 7 〉	통과 (0.04ms, 33.1MB)
// 테스트 8 〉	통과 (0.05ms, 33.1MB)
// 테스트 9 〉	통과 (0.05ms, 33.4MB)
// 테스트 10 〉	통과 (0.05ms, 33.4MB)
// 테스트 11 〉	통과 (0.04ms, 33.3MB)
// 테스트 12 〉	통과 (0.04ms, 33.4MB)
// 테스트 13 〉	통과 (0.04ms, 33.4MB)
// 테스트 14 〉	통과 (0.05ms, 33.4MB)
// 테스트 15 〉	통과 (0.05ms, 33.1MB)
// 테스트 16 〉	통과 (0.05ms, 32.9MB)
// 테스트 17 〉	통과 (0.03ms, 33.3MB)
// 효율성  테스트
// 테스트 1 〉	통과 (46.40ms, 81.7MB)
// 테스트 2 〉	통과 (48.37ms, 83MB)
// 테스트 3 〉	통과 (43.51ms, 83.2MB)
// 테스트 4 〉	통과 (45.01ms, 83MB)
//정확성: 71.9
// 효율성: 28.1
